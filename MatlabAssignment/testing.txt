Testing has been carried out primarily within the test function, split into distinct blocks - each testing a different aspect of the program:

-> First block tests support functions that are employed regularly within other functions (is_varname / is_string / str2int / get_digits). Testing has been carried out to ensure that these functions work as intended, and that they return an error (NON_ZERO [-1]) with incorrect usage. str2int can return negative integers, but their use is prohibited based on the formal grammar's definition of an integer. Strings must be enclosed in double quotation marks. Quotation marks are removed only when printing occurs, within the print functions.

-> The second block of tests focus on parsing. The approach to loading the program with MATLAB script for testing was to strcpy each word in to the word list stored inside the Program Struct. At this stage, the functionality of the code is not being tested - simply it is checking to see that, with correct usage, SUCCESS [0] is returned, and with incorrect usage the appropriate error value (from a variety of #define's for each scenario) is returned. Each word, for each instruction, has been replaced with an invalid example and the output is assertion tested to ensure the program is running as intended. This section of testing will run in either Parse or Interp mode.

Subsequent blocks of testing are guarded behind an #ifdef and will only execute if it has been compiled for Interp. This was decided on in order to reduce unnecessary code being compiled and executed for the Parser.

Any words in the word list are removed before proceeding with further testing.

-> The third, quite short, block tests pushdown of integers. An integer is loaded onto the word list, and polish is called. This function pushes the integer onto the stack but does not proceed any further. This is carried out for two integers, and the stack is then checked to confirm that the two integers are present, in the correct order, and that the stack size is 2. The stack is then cleared before continuing to the next testing block.

-> The fourth testing block explores the SET instruction, and each of the unary and binary operations. Variables $A to $G are created, and end of line comments are used for ease of reference when their final values are stored. All variables are scalar-only for this block. Testing includes setting using pushdown integers, error checking for negative integers, and all operations are subsequently tested. Importantly, incorrect polish list instructions are tested for (i.e. having insufficient variables on the stack prior to calling a Unary or Binary Operation, or having too many variables [>1] on the stack after all operations have been carried out). This has been caught for both the Interpreter and Parser using the valid_set function. For example, all of the following will produce warning errors:
	-> SET $A := 5 B-TIMES ;
	-> SET $C := $A $B B-AND B-OR ;
	-> SET $D := $A $B B-TIMES $C U-NOT ;

-> Before continuing to the next block, the variable list is cleared, freed, and re-allocated, and the wordlist is cleared. The fifth testing block focuses on arrays. First ONES are created and manipulated through unary operations, and the output of these processes are assertion tested from the variable list. At this stage, testing is now being carried out using the function code(), therefore the stack will always be empty and so the variable list must be the point of reference for assertion testing. Testing here is for correct output, rather than error messages. This is because the previous testing has confirmed that all instructions are working as intended, and this therefore leaves outcomes alone to make assertions on. The one exception to this comes at the end of the testing block (see end of paragraph). The U-EIGHTCOUNT operation is called and each cell of the resulting array is checked to make sure that, for a central single 1, only the cells surrounding it count having one 'true' neighbour. Throughout this section, the variable list is not cleared, but the word list is. This enables new variables to be added whilst older variables can still be accessed and used for calculations. The final section of this testing block ensures that if two arrays are fed into a binary operation, and they have different dimensions, that the error code W_UNEQL is returned. This is not caught by the Parser, as it is a semantic rather than grammatical error.

-> The last test block covers LOOP, and once again the variable list and word list is cleared before proceeding. This brief section runs a loop, doubling a ONES array 5 times. It checks that the variable list is ordered as intended, that the multiplier is unchanged, that the loop counter has gone one value above the bounds set (i.e. has exceeded the loop range and therefore stopped), and that each cell in the array is now 2^5.

The above testing inherently covers: stack functionality (push, pop); the creation of variables and them being added to the variable list; clearing of both the stack and the variable list; validating SET input (valid_set & get_stack_value); and polish functionality.

The error and warning functions could not be directly tested. The warning function is indirectly tested through ensuring that the correct error values are returned in the test function. The error function is reserved specifically for serious failures, such as running out of memory. exit(EXIT_FAILURE) is only used for these serious failures, as incorrect parsing does not represent a failure of the code's execution.

Two functions remain untested at this point: READ and handle_input. Both functions were best tested through the mytest.nlb file that utilises testinput.arr and testlife.arr, all three of which were submitted along with my code. These together act as a comprehensive testing of the entire program.

The test script will use all instructions and operations. It reads in an array file, manipulates this against a ONES array, flips it, multiplies it to show aligned printing when array values have multiple digits or a varied number of digits. It then uses a triple nested loop to output a scalar value of 2^30. Finally, it loads the Life glider (testlife.arr) and produces 20 instances, showing the journey of the glider from corner to corner.

The purpose of the testing carried out within the test function is to focus on the detailed operation of individual functions (ensuring correct error messages return, valid usage, etc.), whilst the three test files have been used for testing and displaying overall functionality.

